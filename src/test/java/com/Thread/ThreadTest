//2
//多线程启动的两种方式之二  ：  继承Thread ,实现 Runnable
class ThreadTest2 {

    public static void main(String[] args) {
        MyThread0 walker =new MyThread0();
        walker.start();
        for(int x=0;x<100;x++)
        {
            try {
                Thread.sleep(100);
            } catch (Exception e) {
            }
            System.out.println("X的值是："+x);
        }
    }
}
class MyThread0 extends Thread{

    public void run() {
        for(int i=0;i<100;i++)
        {
            try {
                Thread.sleep(100);
            } catch (Exception e) {
            }
            System.out.println("i的值是："+i);
        }
    }

}
//3
//sleep interrupt 方法测试
class ThreadTest3 {

    public static void main(String[] args) {
        MyThread md=new MyThread();
        md.start();
        try {
            Thread.sleep(10000);
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("main线程在运行");
//		md.shutdown();
        System.out.println("MyThread线程已经结束");
        md.interrupt();//中断md线程，sleep方法被中断，抛出的异常被catch处理，
        //md.stop();---->已过时，不能用了
    }
    public static void useOfDate()			//new Date():获取当前时间
    {
        System.out.println("======="+new Date()+"=========");
        try {
            Thread.sleep(10000);
        } catch (Exception e) {
           e.printStackTrace();
        }
        System.out.println("======="+new Date()+"=========");
    }
}
class MyThread extends Thread
{
    public boolean flag=true;

    public void run(){
        while(flag){
            System.out.println("======="+new Date()+"=========");
            try {
                Thread.sleep(1000);
            } catch (Exception e) {
                e.printStackTrace();
                System.out.println("I'm interrupted,help!help!!!");
                return;
            }
        }
    }
    public void shutdown(){
        flag=false;
    }
}

//4
//join：当前线程执行到 其他线程的join方法时，当前线程会等待其他线程执行完。遇到yield，不会暂停，因为其已经执行join。
class ThreadTest4 {

    public static void main(String[] args) {
        MyThread2 myThread2 =new MyThread2("NGSAN");
        myThread2.start();
        try {
            myThread2.join();// main线程执行到了myThread2线程的join(),这时main线程会停止直到myThread()线程执行完。
        } catch (Exception e) {
        }
        for(int x=0;x<100;x++)
        {
            System.out.println("main......X的值是："+x);
        }
    }
}
class MyThread2 extends Thread
{
    MyThread2(String name)
    {
        super(name);
    }
    public void run()
    {
        for(int i=0;i<100;i++){
            try {
                System.out.println("MyThread2....i的值是："+i);
                Thread.sleep(100);
            } catch (Exception e) {
                System.out.println("MyThread2 is interruted,");
                return;
            }
        }
    }
}

//5
//yield方法使用
/*
 * yield失效问题解释：
 * yield方法jdk解释是暂定当前线程并执行其他线程。换句话说，cpu执行到yield方法时会切换到其他线程的时间片上，而如果
 * 恰好其他线程的时间片不足以执行一条代码，那就造成了当前线程未暂停，而是继续执行了的假象。
 * */
class ThreadTest5 {
    public static void main(String[] args) {
        MyThread3 t1=new MyThread3("ssss");
        MyThread3 t2=new MyThread3("zzzz");
        t1.start();
        t2.start();
    }
}
class MyThread3 extends Thread
{
    public MyThread3(String name) {
        super(name);
    }
    public void run()
    {
        for(int i=0;i<100;i++)
        {
            if(i%10==0)
                yield();	//暂停当前正在执行的线程
            System.out.println(getName()+": "+i);
        }
    }
}
//6
//setPriority:设置优先级...       优先级：MAX_PRIORITY(10)		NORM_PRIORITY(5)	MIN_PRIORITY(1)
class ThreadTest6 {

    public static void main(String[] args) {
        Thread thread1=new Thread(new PriorityThread1());
        Thread thread2=new Thread(new PriorityThread2());
        thread1.setPriority(Thread.MAX_PRIORITY);	//虽然thread1的线程优先级是最高的，但是并不意味着只有此最高优先级线程执行完之后其他线程才能执行
        thread1.start();
        thread2.start();
        //System.out.println(thread1.MIN_PRIORITY);
    }
}
class PriorityThread1 implements Runnable
{
    public void run()
    {
        for(int i=0;i<100;i++)
        {
            try {
                //Thread.sleep(100);
            } catch (Exception e) {
                e.printStackTrace();
            }
            System.out.println("PriorityThread1/++++++"+i);
        }
    }
}
class PriorityThread2 implements Runnable
{
    public void run()
    {
        for(int i=0;i<100;i++)
        {
            System.out.println("PriorityThread2/....."+i);
        }
    }
}

//7
//多线程同时访问共享数据导致并发问题 -> synchronized 锁使用
class ThreadTest7 implements Runnable {
    MyThread4 timer =new MyThread4();
    public static void main(String[] args) {
        ThreadTest7 test =new ThreadTest7();
        Thread t1=new Thread(test);
        Thread t2=new Thread(test);
        t1.setName("t1");
        t2.setName("t2");
        t1.start();
        t2.start();
    }
    @Override
    public void run() {
        timer.add(Thread.currentThread().getName());		//Thread.currentThread()	返回当前执行的线程的引用
    }
}
class MyThread4
{
    int num=0;
    public void add(String name)
    {
        while(true)
        {
            synchronized (this) {
                num++;
                try {
                    Thread.sleep(100);
                } catch (Exception e) {
                }
                System.out.println(name+"你是第"+num+"个执行此方法的线程");
            }
        }
    }
}

